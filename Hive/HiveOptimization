TECHNIQUE #1: USE TEZ
---------------------
Hive can use the Apache Tez execution engine instead of the venerable Map-reduce engine. 

>set hive.execution.engine=tez;

TECHNIQUE #2: USE ORCFILE
-------------------------
Hive supports ORCfile, a new table storage format that sports fantastic speed improvements through techniques like predicate push-down, compression and more.
ORC supports compressed storage (with ZLIB or as shown above with SNAPPY) but also uncompressed storage.

>CREATE TABLE A_ORC (
customerID int, name string, age int, address string
) STORED AS ORC tblproperties (“orc.compress" = “SNAPPY”);

TECHNIQUE #3: USE VECTORIZATION
-------------------------------
Vectorized query execution improves performance of operations like scans, aggregations, filters and joins, by performing them in batches of 1024 rows at once instead of single row each time.

>set hive.vectorized.execution.enabled = true;
>set hive.vectorized.execution.reduce.enabled = true;

TECHNIQUE #4: COST BASED QUERY OPTIMIZATION
-------------------------------------------
Hive optimizes each query’s logical and physical execution plan before submitting for final execution. These optimizations are not based on the cost of the query – that is, until now.
A recent addition to Hive, Cost-based optimization, performs further optimizations based on query cost, resulting in potentially different decisions: how to order joins, which type of join to perform, degree of parallelism and others.
To use cost-based optimization (also known as CBO), set the following parameters at the beginning of your query:

>set hive.cbo.enable=true;
>set hive.compute.query.using.stats=true;
>set hive.stats.fetch.column.stats=true;
>set hive.stats.fetch.partition.stats=true;

TECHNIQUE #5: WRITE GOOD SQL
---------------------------
Consider a click-stream event table:

>CREATE TABLE clicks (
timestamp date, sessionID string, url string, source_ip string
) STORED as ORC tblproperties (“orc.compress” = “SNAPPY”);

Each record represents a click event, and we would like to find the latest URL for each sessionID.

>SELECT clicks.* FROM clicks inner join
(select sessionID, max(timestamp) as max_ts from clicks
group by sessionID) latest
ON clicks.sessionID = latest.sessionID and
clicks.timestamp = latest.max_ts;

In the above query, we build a sub-query to collect the timestamp of the latest event in each session, and then use an inner join to filter out the rest.

While the query is a reasonable solution—from a functional point of view—it turns out there’s a better way to re-write this query as follows:

>SELECT * FROM
(SELECT *, RANK() over (partition by sessionID,order by timestamp desc) as rank FROM clicks) ranked_clicks
WHERE ranked_clicks.rank=1;

Here we use Hive’s OLAP functionality (OVER and RANK) to achieve the same thing, but without a Join.
